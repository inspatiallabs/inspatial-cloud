import convertString from "../../../utils/convert-string.ts";
import type { EntryType } from "../../entry/entry-type.ts";
import { buildFields } from "./build-fields.ts";

export function generateClientEntryTypes(entryTypes: Array<EntryType>) {
  const generatedEntries: string[] = [];
  const entryTypeNames = new Map<string, string>();
  for (const entryType of entryTypes) {
    entryTypeNames.set(
      entryType.name,
      convertString(entryType.name, "pascal", true),
    );
    const entryInterface = generateClientEntryInterface(entryType);
    entryInterface && generatedEntries.push(entryInterface);
  }
  const outLines: string[] = [
    ...generatedEntries,
    "",
    "export type EntryMap = {",
    ...Array.from(entryTypeNames.entries()).map(
      ([name, className]) => `  ${name}: ${className}`,
    ),
    "}",
    "",
    "export type EntryName = keyof EntryMap;",
    "export type Entry<E extends EntryName = EntryName> = EntryMap[E];",
  ];
  return [
    "// This file is generated by the InSpatial Cloud Backend.",
    "// Do not edit this file directly.",
    "",
    ...outLines,
  ].join("\n");
}
export function generateClientEntryInterface(
  entryType: EntryType,
): string | undefined {
  // if (!entryType.dir) {
  //   return;
  // }
  const className = convertString(entryType.name, "pascal", true);
  const outLines: string[] = [
    `export interface ${className} {`,
    ` _name:"${convertString(entryType.name, "camel", true)}"`,
  ];

  const fields = buildFields(entryType.fields);
  outLines.push(...fields);
  for (const child of entryType.children?.values() || []) {
    const childFields = buildFields(child.fields);
    outLines.push(
      `${child.name}: Array<{ ${childFields.join("\n")}}>`,
    );
  }
  outLines.push("}");
  return outLines.join("\n");
}
